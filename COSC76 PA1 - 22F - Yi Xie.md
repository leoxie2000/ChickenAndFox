# COSC76 PA1 - 22F - Yi Xie

## Description
The way I appraoched the problem followed the general object oriented programming appraoch. First, I completed the fox problem class where I defined what possible successor states are and the legal states. After that, I implemented the general search algorithms and added the usage of the solution class. In the successor state generation, I designed it with care such that when the boat state is 1, I always tried to ship the maximum amount of chicken, and if the boat is on the other side, I attempt to let a single chicken row the boat back if possible to maintain balance. In fact, I believe this problem has a greedy solution and with the proper state generation, we can find paths that are the same length as nodes visited.

## Evaluation
The algorithm I implemented works correctly on all the test cases. We can check that it succeeded by printing the path and checking they are valid. The solution was able to find path length of 12 for problem (3,3,1) with bfs, dfs, and ids. In addition, it found a path length solution of 16 for problem (5,4,1). If given more time, we can use dymamic programming to check the optimality of these solutions or build a complete state graph and run Belmont Ford for the shortest path. The problem (5,5,1) turns out to have no solution. One observation is that Ids visits significantly more nodes than both bfs and dfs which makes sense since it restarts the search whenever we increment the level. 
## Discussion
First we consider the upper bound of possible states. When given a problem that starts with x chickens and y foxes, the maximum number of states without considering illegality would be 2xy. This is because we have x choices for number of chickens, y choices for number of foxes, and 2 choices for the state of the boat.

For the next question, we notice that since we are doing path-checking and state checking searches, let S be the total number of states, M the maximum depth, and d the depth of the shallowest solution. Notice that path-checking dfs in the worst case runs in O(S) but the memory is only O(M). Meanwhile, bfs also runs in O(S) but the memory is also O(S) since it keeps the entire state graph as visited set. The DFS would take significantly more time if the solution is on the right most branch while being shallow, thus bfs would be able to find it much sooner. On the contrary, memoizing DFS does not save more memory compared to BFS. On the worst case, both search methods still have an O(S) memory, but on an average case, bfs will even take less memory since it will find the shallowest solution.

Lossy Chicken and Foxes: The change is that on every original legal state, we have E extra legal states. So the upper bound will be 2xy+Exy. For me to implement, I will change the  "validify_state" function, since the states generation do not change but legal states changed. In addition, in the foxandchickens class, I will add a self.eaten to keep track of the total chickens being eaten so far, and add subtract according as I enter different nodes.
